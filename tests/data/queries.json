{
  "create_replication_slot": "SELECT true FROM pg_create_physical_replication_slot(%(slot)s);",
  "database_alter_owner": "ALTER DATABASE {database} {options};",
  "database_create": "CREATE DATABASE {database} {options};",
  "database_drop": "DROP DATABASE {database};",
  "database_exists": "SELECT true FROM pg_database WHERE datname = %(database)s;",
  "database_inspect": "SELECT\n    r.rolname AS owner\nFROM\n    pg_database db\n    JOIN pg_authid r ON db.datdba = r.oid\nWHERE\n    db.datname = %(datname)s;",
  "database_list": "SELECT d.datname as \"name\",\n    pg_catalog.pg_get_userbyid(d.datdba) as \"owner\",\n    pg_catalog.pg_encoding_to_char(d.encoding) as \"encoding\",\n    d.datcollate as \"collation\",\n    d.datctype as \"ctype\",\n    d.datacl AS \"acls\",\n    pg_catalog.pg_database_size(d.datname) as \"size\",\n    t.spcname as \"tablespace\",\n    pg_catalog.pg_tablespace_location(t.oid) as \"tablespace_location\",\n    pg_catalog.pg_tablespace_size(t.oid) as \"tablespace_size\",\n    pg_catalog.shobj_description(d.oid, 'pg_database') as \"description\"\nFROM pg_catalog.pg_database d\nJOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid\nWHERE datallowconn\nORDER BY 1;",
  "drop_replication_slot": "SELECT true FROM pg_drop_replication_slot((SELECT slot_name FROM pg_replication_slots WHERE slot_name = %(slot)s));",
  "role_alter": "ALTER ROLE {username} {options};",
  "role_alter_password": "ALTER ROLE {username} PASSWORD %(password)s;",
  "role_create": "CREATE ROLE {username} {options};",
  "role_drop": "DROP ROLE {username};",
  "role_exists": "SELECT true FROM pg_roles WHERE rolname = %(username)s;",
  "role_grant": "GRANT {rolname} TO {rolspec};",
  "role_has_password": "SELECT\n    rolpassword IS NOT NULL FROM pg_authid\nWHERE\n    rolname = %(username)s;",
  "role_inspect": "SELECT\n    CASE WHEN r.rolpassword IS NOT NULL THEN\n        '<set>'\n    ELSE\n        NULL\n    END AS password,\n    r.rolinherit AS inherit,\n    r.rolcanlogin AS login,\n    CASE WHEN r.rolconnlimit <> - 1 THEN\n        r.rolconnlimit\n    ELSE\n        NULL\n    END AS connection_limit,\n    r.rolvaliduntil AS validity,\n    CASE WHEN COUNT(gi) <> 0 THEN\n        ARRAY_AGG(gi.rolname)\n    ELSE\n        ARRAY[]::text[]\n    END AS in_roles\nFROM\n    pg_authid r\n    LEFT OUTER JOIN pg_auth_members g ON g.member = r.oid\n    LEFT OUTER JOIN pg_authid gi ON g.roleid = gi.oid\nWHERE\n    r.rolname = %(username)s\nGROUP BY\n    r.rolpassword, r.rolinherit, r.rolcanlogin, r.rolconnlimit, r.rolvaliduntil;",
  "role_revoke": "REVOKE {rolname} FROM {rolspec};"
}